---
title: Introduce to apollo prediction module
categories: algorithm
tags:
  - apollo
  - autodrive
  - prediction
mathjax: true
comments: true
date: 2020-06-16 21:09:06
---

The prediction module studies and predicts the behavior of all the obstacles detected by the perception module. Prediction receives obstacle data along with basic perception information including positions, headings, velocities, accelerations and then generates predicted trajectories with probabilities for those obstacles.

<!-- more -->
## Input
  - **Obstacles** information from the perception module
  - **Localization** information from the localization module
  - **Planning trajectory** of the previous computing cycle from the planning module

## Output
  - Obstacles annotated with predicted trajectories and their priorities. Obstacle priority is now calculated as individual scenarios are prioritized differently. The priorities include: ignore, caution and normal (default)

## Functionalities
Based on the figure below, the prediction module comprises of 4 main functionalities: Container, Scenario, Evaluator and Predictor.
```
Localization +-------------+          +-------------+           +-------------+          +-------------+
pose         |             |          |             |           |             |          |             |
+------------>             |          |             |           |             |          |             |
Planning     |             |structured|             | Scenario  |             |Lane      |             |Predicted
trajectory   |             |obstacle  |             | type      |             |probability             |trajectory
+------------>  CONTAINER  +---------->  SCENARIO   +----------->  EVALUATOR  +---------->  PREDICTOR  +---------->
Perception   |             |          |             |           |             |          |             |
obstacles    |             |          |             |           |             |          |             |
+------------>             |          |             |           |             |          |             |
             |             |          |             |           |             |          |             |
             +-------------+          +-------------+           +-------------+          +-------------+
```

### Container

Container stores input data from subscribed channels. Current supported inputs:
- perception obstacles
- vehicle localization
- ego vehicle planning trajectory

#### Architecture

The architecture of the **container** is as below. The class `Container` defines the interface of all containers and it can't be realized because it has a pure virtual function `Insert`. `PoseContainer`, `ADCTrajectoryContainer` and  `ObstacleContainer` are derived from `Container` and realize the `Insert` function.
The `ContainerManager` class **has** many containers. It generates all three types of contianer and stores them in an unordered map to speed up the search process.
I just list some important methods of the class here, for more functions and their description, you can read the documents generated from `doxygen`.

![container](/images/2020-06-16-Introduce-to-apollo-prediction-module/container.png)

Current container contains:
- PoseContainer
- ADCTrajectoryContainer
- ObstacleContainer

#### PoseContainer
`PoseContainer` receives localization message:
- position(3d);
- theta(orientation);
- velocity(3d);

and insert ego vehicle as an obstacle into `ObstacleContainer` with id `-1` and type `VEHICLE`.

#### TrajectoryContainer
`TrajectoryContainer` receives trajectory message from planning and sets the information of current lane:
- junction id;
- the distance to junction;
- lane sequence;
- overlaps of the lane.

#### ObstacleContainer
![obstacle container](/images/2020-06-16-Introduce-to-apollo-prediction-module/container_obstacle.png)
`ObstacleContainer` structures and stores all obstacles from perception, it **has a** `LRU(Latest Recently Used)Cache` class to manage the latest recently used 10 items. The `value` of LRUCache is the obstacle and the `key`  is the id of the obstacle. The functionality of `ObstacleContainer` **depends on** the class `ObstacleCluster`, because method `SortObstacle` is used.

##### ObstacleCluster
`ObstacleCluster` contains not only `Obstcles` in an unordered map to speedup `set` and `get` but also the relationship between `Obstacles` and `LaneGraphs` from `HdMap` like `Overlaps` and `Stopsigns`.

##### Obstacle
`Obstacle` class is a basic unit to store `Obstacles` generated by `perception` module. It stores the information of a obstacle in a data structure `Feature` which is defined in google's data interchange format [protobuf](https://developers.google.com/protocol-buffers/). The proto `Feature` is as below:
```protobuf
message Lane {
  // Features of all possible current lanes.
  repeated LaneFeature current_lane_feature = 1;

  // Features of the most possible current lane.
  optional LaneFeature lane_feature = 2;

  // Features of all nearby lanes.
  repeated LaneFeature nearby_lane_feature = 3;

  // Lane graph
  optional LaneGraph lane_graph = 4;
  optional LaneGraph lane_graph_ordered = 5;

  // For modeling
  optional double label_update_time_delta = 26;
}

message LaneFeature {
  optional string lane_id = 1;
  optional uint32 lane_turn_type = 2;
  optional double lane_s = 3;
  optional double lane_l = 4;
  optional double angle_diff = 5;
  optional double dist_to_left_boundary = 6;
  optional double dist_to_right_boundary = 7;
  optional double lane_heading = 8;
  optional adu.common.hdmap.Lane.LaneType lane_type = 9;
}

message JunctionExit {
  optional string exit_lane_id = 1;
  optional adu.common.Point3D exit_position = 2;
  optional double exit_heading = 3;
  optional double exit_width = 4;
}

message JunctionFeature {
  optional string junction_id = 1;
  optional double junction_range = 2;
  optional LaneFeature enter_lane = 3;
  repeated JunctionExit junction_exit = 4;
  repeated double junction_mlp_feature = 5;
  repeated int32 junction_mlp_label = 6;  // dim is number of masks, i.e. 12
  repeated double junction_mlp_probability = 7;
  repeated string start_lane_id = 8;
}

message ObstaclePriority {
  enum Priority {
    CAUTION = 1;
    NORMAL = 2;
    IGNORE = 3;
  }
  optional Priority priority = 25 [default = NORMAL];
}

// next id = 35
message Feature {
  // Obstacle ID
  optional int32 id = 1;

  // Obstacle features
  repeated adu.common.Point3D polygon_point = 30;
  optional adu.common.Point3D position = 2;
  optional adu.common.Point3D front_position = 27;
  optional adu.common.Point3D velocity = 3;
  optional adu.common.Point3D raw_velocity = 28;  // from perception
  optional adu.common.Point3D acceleration = 4;
  optional double velocity_heading = 5;
  optional double speed = 6;
  optional double acc = 7;
  optional double theta = 8;
  optional double length = 9;
  optional double width = 10;
  optional double height = 11;
  optional double tracking_time = 12;
  optional double timestamp = 13;

  // Obstacle type-specific features
  optional Lane lane = 14;
  optional JunctionFeature junction_feature = 26;

  // Obstacle tracked features
  optional adu.common.Point3D t_position = 16;
  optional adu.common.Point3D t_velocity = 17 [deprecated = true];
  optional double t_velocity_heading = 18 [deprecated = true];
  optional double t_speed = 19 [deprecated = true];
  optional adu.common.Point3D t_acceleration = 20 [deprecated = true];
  optional double t_acc = 21 [deprecated = true];

  optional bool is_still = 22 [default = false];
  optional adu.common.perception.PerceptionObstacle.Type type = 23;
  optional double label_update_time_delta = 24;

  optional ObstaclePriority priority = 25;

  optional bool is_near_junction = 29 [default = false];

  // Obstacle ground-truth labels:
  repeated PredictionTrajectoryPoint future_trajectory_points = 31;

  // Obstacle short-term predicted trajectory points
  repeated adu.common.TrajectoryPoint
      short_term_predicted_trajectory_points = 32;

  // Obstacle predicted trajectories
  repeated Trajectory predicted_trajectory = 33;

  // ADC trajectory at the same frame
  repeated adu.common.TrajectoryPoint adc_trajectory_point = 34;
}

message ObstacleHistory {
  repeated Feature feature = 1;
  optional bool is_trainable = 2 [default = false];
}

message FrameEnv {
  optional double timestamp = 1;
  optional ObstacleHistory ego_history = 2;
  repeated ObstacleHistory obstacles_history = 3;
}
```

In addtion to the information about the obstacle, `Obstacle` uses
- a `KalmanFilter` to track the trajectory of pedestrian;
- a `KalmanFilter` to track the trajectory of other obstacles(vehicle, bicycle, etc.)
- a `DigitalFilter` to filter the heading of bicycles and pedestrians.

`Obstacle` contains many methods about obstacle's property:

###### `IsStill`: return true if the obstacle is still.
There are two checks to determine whether an obstacle is still or not:
- distance check.
- speed check.

Firstly, we can calculate the average distance deviation of an obstacle's history position:
$$
x_{avg} = \sum_{i = 1}^{n} \frac{x_{i} - x_{0}}{n - 1} \tag{1}
$$
$$
y_{avg} = \sum_{i = 1}^{n} \frac{y_{i} - y_{0}}{n - 1} \tag{2}
$$

In the above equations,
- $x_{avg}$ is the average distance deviation of $x$;
- $y_{avg}$ is the average distance deviation of $y$;
- $n$ is the history size of an obstacle, in the program is $10$;
- $x_{i}$ is the `i`th $x$ of the position in history;
- $y_{i}$ is the `i`th $y$ of the position in history;
- $x_{0}$ is the current $x$ of the position of an obstacle;
- $y_{i}$ is the current $y$ of the position of an obstacle.

Then, the speed sensibility is defined as:
$$
K_{v} = \frac{\sqrt{2 * n} * 4 * k_{std}}{(n + 1) * d_{t}} \tag{3}
$$
In the equation:
- $K_{v}$ is the sensibility of speed;
- $n$ is the history size of an obstacle;
- $k_{std}$ is the position standard deviation of an obstacle, it's $1.0$(obstacle) or $0.5$(other) in program;
- $d_{t}$ is the duration of the history.

Nextly, we calculate the distance:
$$
D = \sqrt{x_{avg}^2 + y_{avg}^2}
$$
$$
D_{std} = \sqrt{\frac{2.0}{n}} * k_{std}
$$
In the equation:
- $D$ is the distance of obstacle;
- $D_{std}$ is the standard distance of obstacle, it's $1.0$ in program;


Now we can determine the obstacle is:
- still, if $v < v_{threshold}$($v$ is current speed, $v_{threshold}$ is the threshold of speed, it's $0.8$(obstacle) or $0.5$(other) in program);
- not still, if $v > v_{threshold}$ and $K_{v} < v_{threshold}$;
- not still, if $v > v_{threshold}$ and $K_{v} > v_{threshold}$ and $D > 2.0 * D_{std}$;
- still, if $v > v_{threshold}$ and $K_{v} > v_{threshold}$ and $D < 2.0 * D_{std}$;

### Scenario

The `Scenario` sub-module analyzes scenarios that includes the ego vehicle.
Currently, two scenarios are defined:
- **Cruise** : this scenario includes Lane keeping and following.
- **Junction** : this scenario involves junctions. Junctions can either have traffic lights and/or STOP signs.

The architecture of `Scenario` is as below:
![scenario](/images/2020-06-16-Introduce-to-apollo-prediction-module/scenario.png)

#### ScenarioManager
The `ScenarioManager` class **depends on** `FeatureExtractor` to generate environment features and **depends on** `ScenarioAnalyzer` to analyze current scenario. If necessary, `ScenarioManager` will set obstacls' priorities as:
- IGNORE, if the obstacle is no need to consider;
- NORMAL, if the obstacle needs to be considered.

![priority](/images/2020-06-16-Introduce-to-apollo-prediction-module/priority.png)

The obstacle is set to `NORMAL` if the obstacle is:
- in scan area, the scan arear is a rectanglar in front of ego vehicle with the length($80$ in program) and width($12$ in program), for example, the obstacle with id of 5 is in scan area but 6 not;
- on lane, for example, the obstacle with id of 3 is on lane but 2 not;
- near junction, means that the distance between obstacle and junction is less than threshold(it's $1$ in program), see obstacle 4 and 5;
- near lane, this rule is not for the obstacle with the type of `VEHICLE`, if the distance is less than threshold($3$ in program), obstacle 2 and 3 is near lane.

Otherwise the priority of the obstacle is `IGNORE`.

#### FeatureExtractor
`FeatureExtractor` sets
- Ego lane feature, including ego lane id and s of lane;
- Left and right lane feature, including lane id and s of lane;
- Junction feature, including junction id, we only consider the junction that has signals or stop signs. 

#### ScenarioAnalyzer
`ScenarioAnalyzer` determines which scene ego vehicle is in:
- Junction, if the distance between ego vehicle and junction is less than threshold($10$ in program);
- Cruise, otherwise.

`ScenarioAnalyzer` works **depends on** `ScenarioFeatures`. Once which scenario is determined, it will generate corresponding scenario features.

#### ScenarioFeatures
`CruiseScenariosFeatures` and `CruiseScenariosFeatures` are derived from the base class `ScenarioFeatures`.

### Evaluator

The `Evaluator` predicts path and speed separately for any given obstacle. An evaluator evaluates a path by outputting a probability for it (lanesequence) using the given model stored in `prediction/data/`.

Now in `prediction`, the `Evaluator` for `Cyclist` are:
- `CyclistKeepLaneEvaluator`: ;

and the `Evaluator` for `Vehicle` are:
- `CostEvaluator`: probability is calculated by a set of cost functions;
- `MLPEvaluator`: probability is calculated using an MLP model;
- `RNNEvaluator`: probability is calculated using an RNN model;
- `CruiseMLPEvaluator`: probability is calculated using a mix of MLP and CNN-1d models for the cruise scenario;
- `JunctionMLPEvaluator`: probability is calculated using an MLP model for junction scenario.

The architecture of `Evaluator` is as below:
![evaluator](/images/2020-06-16-Introduce-to-apollo-prediction-module/evaluator.png)

#### EvaluatorManager
The `EvaluatorManager` creates and stores all types of evaluators, so it **has** many `Evaluator` pointers. The `Evaluator` class is a base class that defines a pure virtual function `Evaluate`. `EvaluatorManager` calls `Evaluator`'s subclass's function `Evaluate` to calculate probability for a lanesequence. If the `obstacle` type is:
- `VEHICLE` and it's 
 - `ON_LANE`, the `Evaluator` will be `CruiseMLPEvaluator`;
 - `IN_JUNCTION`, the `Evaluator` will be `JunctionMLPEvaluator`;
- `BICYCLE` and it's
 - `ON_LANE`, the `Evaluator` will be `CyclistKeepLaneEvaluator`;
- `UNKNOWN` and it's
 - `ON_LANE`, the `Evaluator` will be `MLPEvaluator`;

otherwise, the `Evaluator` would not work.

#### CyclistEvaluator
The `CyclistEvaluator` is simple and has only two probability values:
- 1.0, if current lane id is equal to the lane id in lane sequence;
- 0.0, if current lane id is not equal to the lane id in lane sequence.

The lanes sequence is a list of lane id that covers the length:
$$
D_{lane} = v_{0} * t_{max} + 0.5 * a_{max} * t_{max}^2
$$
In equation,
- $D_{lane}$ is the distance the lane sequance covers;
- $v_{0}$ is current speed the obstacle has;
- $t_{max}$ is the predicted trajectory duration, it's 8.0 in program;
- $a_{max}$ is the maximum linear acceleration of vehicle, it's 4.0 in program;

#### CostEvaluator
`CostEvaluator` calculates the probability based on the distance between obstacle and lane boundary.
$$
E_{l} = W_{lane} - W_{l}
$$
$$
P_{cost} = \frac{1}{1 + e^{-E_{l}}}
$$

In the equation:
- $E_{l}$ is the distance from lane boundary to obstacle's location;
- $W_{lane}$ is the width of lane;
- $W_{l}$ is the lateral distance from lane reference line to obstacle's location;
- $P_{cost}$ is the probability, calculated by a [Sigmoid function](https://en.wikipedia.org/wiki/Sigmoid_function).

#### MLPEvaluator
TODO

#### RNNEvaluator
TODO

#### CruiseMLPEvaluator
TODO

#### JunctionMLPEvaluator
TODO

### Predictor

Predictor generates predicted trajectories for obstacles. Currently, the supported predictors include:

- **Empty**: obstacles have no predicted trajectories;
- **Single lane**: Obstacles move along a single lane in highway navigation mode. Obstacles not on lane will be ignored;
- **Lane sequence**: obstacle moves along the lanes;
- **Move sequence**: obstacle moves along the lanes by following its kinetic pattern;
- **Free movement**: obstacle moves freely;
- **Regional movement**: obstacle moves in a possible region;
- **Junction**: Obstacles move toward junction exits with high probabilities.

The relationship between `predictor`s is as below:
![predictor](/images/2020-06-16-Introduce-to-apollo-prediction-module/predictor.png)

#### PredictorManager
`PredictorManager` creates and stores all kinds of `predictor`s. It **has** pointers of base class `Predictor` to points to its subclasses, the specail predictors.
`PredictorManager` runs the special predictor's method `Predict` to generate trajectories according to obstacles's type. If the obstacle's type is:
- `Vehicle`, and it's
 - `InJunction`, the predictor will be `LaneSequencePredictor`;
 - `OnLane`, the predictor will be `MoveSequencePredictor`;
 - `OffLane`, the predictor will be `FreeMovePredictor`;
- `Pedestrian`, the predictor will be `FreeMovePredictor`;
- `Bicycle`, and it's
 - `OnLane`, the predictor will be `MoveSequencePredictor`;
 - `OffLane`, the predictor will be `FreeMovePredictor`;
- `Unknown`, and it's
 - `OnLane`, the predictor will be `MoveSequencePredictor`;
 - `OffLane`, the predictor will be `FreeMovePredictor`;
- other case, the predictor will be `EmptyPredictor`.

#### Predictor
`Predictor` is a base class with the pure virtual function `Predict`. It also realizes some methods about trajectories:

##### TrimTrajectory
If the obstacle is in junction, we don't trim obstacle's trajectory; otherwise, trim the trajectory to the front of junction.

##### SupposedToStop
Determine if an obstacle is supposed to stop within a distance.

#### EmptyPredictor
`EmptyPredictor` does nothing but clear the trajectory of obstacle.

#### FreeMovePredictor
`FreeMovePredictor` assumes that the obstacle always moves with initial velocity and acceleration, the state is:
$$
\begin{bmatrix}
x \\\\
y \\\\
x^\prime \\\\
y^\prime \\\\
x^{\prime\prime} \\\\
y^{\prime\prime}
\end{bmatrix}
$$

and the transition matrix is:
$$
\begin{bmatrix}
1 & 0 & t & 0 & 0.5 * t^2 & 0 \\\\
0 & 1 & 0 & t & 0 & 0.5 * t^2 \\\\
0 & 0 & 1 & 0 & t & 0 \\\\
0 & 0 & 0 & 1 & 0 & t \\\\
0 & 0 & 0 & 0 & 1 & 0 \\\\
0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix}
$$

#### JunctionPredictor
`JunctionPredictor` uses a cubic polynomial to fit start-point(obstacle's position) and end-point(junction exit position) within given time.

#### RegionalPredictor
Not used in program.

#### SequencePredictor
`SequencePredictor` defines some common methods relatived to sequence.

##### FilterLaneSequence
This method filters out those obstacles that are close to the ego vehicle so that we will ignore them and drive normally unless they really kick into our lane.

#### LaneSequencePredictor
`LaneSequencePredictor` is derived from `SequencePredictor`. After filtering lane sequence, it use the method from `Predictor` to check if an obstacle is to stop:
- `true`, generate constant acceleration trajectory;
- `false`, generate lane sequence trajectory.

##### Constant acceleration trajectory
In this case, `predictor` refresh trajectory point with the equation:
$$
s = v * t + 0.5 * a * t^2
$$
$$
v = v_0 + a * t
$$
$$
l = l_0 * K_{approach}
$$
In equation:
- $s$ is the obstacle distance on the lane;
- $v$ is current velocity;
- $t$ is the duration;
- $a$ is current acceleration;
- $v_0$ is the velocity from last step;
- $l$ is the lateral distance between obstacle and lane reference line;
- $l_0$ is the lateral distance last step.
- $K_{approach}$ is the coefficient that obstacle moves towards lane reference line;

##### Lane sequence trajectory
In this case, we assume that the obstacle moves with constant velocity:
$$
s = s_0 + v * t
$$
$$
l = l_0 * K_{approach}
$$

#### MoveSequencePredictor
`MoveSequencePredictor` is derived from `SequencePredictor`. After filtering lane sequence, it use the method from `Predictor` to check if an obstacle is to stop:
- `true`, generate constant acceleration trajectory;
- `false`, generate lane sequence trajectory using best trajectory selection.

##### Const acceleration trajectory
This trajectory is the same as LaneSequencePredictor

##### Lane sequence trajectory using best trajectory selection
This trajectory traverses all the time to reach the end point and selects the best trajectory that has the minimum cost.
1. Generate a list of time to reach the end.
In program, we use the method `GenerateCandidateTimes` with the time gap of $0.5$ and end time $8.0$ to generate a sample time list: `{0, 0.5, 1, 1.5, ..., 7.5, 8.0}`.
2. Calculate the 5th degree polynomial of lateral ditance with each end time.
Since we have known the start state:
$$
\begin{cases}
l_{0} = l_{obstacle} \\\\
l_{0}^\prime = v_{lateral} \\\\
l_{0}^{\prime\prime} = 0
\end{cases}
$$
and end state:
$$
\begin{cases}
l_{1} = 0 \\\\
l_{1}^{\prime} = 0 \\\\
l_{1}^{\prime\prime}= 0
\end{cases}
$$

with the 5th degree polynomial equation:
\begin{cases}
l = a_0 + a_1 \cdot t + a_2 \cdot t^2 + a_3 \cdot t^3 + a_4 \cdot t^4 + a_5 \cdot t^5 \\\\
l^{\prime} = a_1 + 2 \cdot a_2 \cdot t + 3 \cdot a_3 \cdot t^2 + 4 \cdot a_4 \cdot t^3 + 5 \cdot a_5 \cdot t^4 \\\\
l^{\prime\prime} = 2 \cdot a_2 \cdot t + 6 \cdot a_3 \cdot t + 12 \cdot a_4 \cdot t^2 + 20 \cdot a_5 \cdot t^3
\end{cases}

we can get the coefficients $a_0$ to $a_5$.

2. Calculate the 4th degree polynomial of longitude distance with each end time.
Since we have known the start state:
$$
\begin{cases}
s_{0} = l_{obstacle} \\\\
s_{0}^\prime = v_{lateral} \\\\
s_{0}^{\prime\prime} = 0
\end{cases}
$$
and end state:
$$
\begin{cases}
s_{1} = s_{end} \\\\
s_{1}^{\prime} = v_{end} \\\\
s_{1}^{\prime\prime}= 0
\end{cases}
$$

with the 4th degree polynomial equation:
\begin{cases}
l = a_0 + a_1 \cdot t + a_2 \cdot t^2 + a_3 \cdot t^3 + a_4 \cdot t^4 \\\\
l^{\prime} = a_1 + 2 \cdot a_2 \cdot t + 3 \cdot a_3 \cdot t^2 + 4 \cdot a_4 \cdot t^3 \\\\
l^{\prime\prime} = 2 \cdot a_2 \cdot t + 6 \cdot a_3 \cdot t + 12 \cdot a_4 \cdot t^2
\end{cases}

we can get the coefficients $a_0$ to $a_4$.

3. Find the coefficients of lateral and longitude with the lowest cost.
The cost of each group of coefficients can be calculated with:
$$
C = a_{max lateral} + \alpha * t_{end}
$$
In equation,
- $C$ is the cost;
- $\alpha$ is ratio of time, it's $0.25$ in program;
- $t_{end}$ is the time to reach end point.

4. Generate each point of the trajectory with the lowest cost.
Now that we know the equation of longitude and lateral and the time to reach end point, we can generate each point of the trajectory with  time gap($0.1$ in program)


#### SingleLanePredictor
This `predictor` uses the same method as `LaneSequencePredictor` lane sequence case.
